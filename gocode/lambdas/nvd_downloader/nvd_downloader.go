package main

import (
	"fmt"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/aws/aws-sdk-go/service/s3/s3manager"
	"io"
	"log"
	"net/http"
	"os"
)

const NVD_URL_HASH_KEY = "nvd_urls"

type NvdUrls struct {
	HashKey string `json:"hash_key"`
	Urls    []Url
}

type Url struct {
	Endpoint string `json:"endpoint"`
	Url      string `json:"url"`
}

func show() {
	urlTable := os.Getenv("VULN_URL_TABLE")

	sess := session.Must(session.NewSessionWithOptions(session.Options{
		SharedConfigState: session.SharedConfigEnable,
	}))
	svc := dynamodb.New(sess)
	urls, err := getUrls(urlTable, svc)
	if err != nil{
		return
	}
	for _, v := range urls {
		log.Printf("%+v", v)
	}
	uploader := s3manager.NewUploader(sess)
	return

}

func getUrls(urlTable string, dynamoSession *dynamodb.DynamoDB) ([]Url, error) {
	result, err := dynamoSession.GetItem(&dynamodb.GetItemInput{
		TableName: aws.String(urlTable),
		Key: map[string]*dynamodb.AttributeValue{
			"hash_key": {
				S: aws.String(NVD_URL_HASH_KEY),
			},
		},
	})
	if err != nil {
		log.Printf("Error getting nvd_urls from dynamodb: %v+", err)
		return nil, err
	}
	urls := NvdUrls{}
	err = dynamodbattribute.UnmarshalMap(result.Item, &urls)
	if err != nil {
		log.Printf("Error getting nvd_urls from dynamodb: %v+", err)
		return nil, err
	}

	return urls.Urls, nil
}

func uploadS3(bucketName string, buckketKey string, filename string, uploader *s3manager.Uploader) error {
	f, err  := os.Open(filename)
	if err != nil {
		return fmt.Errorf("failed to open file %q, %v", filename, err)
	}

	// Upload the file to S3.
	result, err := uploader.Upload(&s3manager.UploadInput{
		Bucket: aws.String(bucketName),
		Key:    aws.String(buckketKey),
		Body:   f,
	}, nil)
	if err != nil {
		return fmt.Errorf("failed to upload file, %v", err)
	}
	fmt.Printf("file uploaded to, %s\n", aws.StringValue(&result.Location))
	return nil
}

func downloadFile(url string, filepath string) error {
	// Create the file
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	// Get the data
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return err
	}

	return nil
}

func main() {
	lambda.Start(show)

}
